# .dynamic

The '.dynamic' section has a section header as well as a program header so that it can be used by the dynamic linker. This section contains arrays of:

```c
typedef struct {
  Elf32_Sword d_tag;
  union {
    Elf32_Word d_val;
    Elf32_Addr d_ptr;
  } d_un;
} Elf32_Dyn;
```

The different types of `d_tag`s are:

1. **DT\_NEEDED**: holds the string table offset to the name of a needed shared library.
2. **DT\_SYMTAB**: contains the address of the dynamic symbol table `.dynsym`.
3. **DT\_HASH**: contains the address of the symbol hash table `.gnu.hash`.
4. **DT\_STRTAB**: contains the address of the symbol string table `.dynstr`.
5. **DT\_PLTGOT**: contains the address of the global offset table.

Clearly, some part (section headers) of a stripped binary can be recovered using the `.dynamic` section.

When the dynamic linker is mapped to the memory, it first handles its own relocations. Then, it looks into the `.dynamic` section and searches for `DT_NEEDED` tags to locate the different shared libraries to be loaded. It then brings the shared library in memory, looks into its `.dynamic` section and adds the library's symbol table to a chain of symbol tables it maintains. It also creates an entry for every shared library:

```c
struct link_map
{
  ElfW(Addr) l_addr; /* Base address shared object is loaded at. */
  char *l_name; /* Absolute file name object was found in. */
  ElfW(Dyn) *l_ld; /* Dynamic section of the shared object. */
  struct link_map *l_next, *l_prev; /* Chain of loaded objects. */
  ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM]; /* Holds pointers to symbol table (l_info[DT_SYMTAB]) and relocation table (l_info[DT_JMPREL]) */
 };
```

Note that the first entry in `link_map` is of the executable binary itself.

During the process of linking external functions, a call is made to `_dl_runtime_resolve` with parameters: the `link_map` struct and the index into the relocation table for that function. The relocation entry gives the index in the symbol table for that function and also the address in GOT to be patched. The symbol is then searched in shared libraries using the `link_map` struct. The search involves the following steps:

1. Generating a hash of the symbol name to be searched for.
2. Lookup the symbol table entry using that index.
3. Lookup the name of that symbol in string table and compare.

If found, the symbol's address is added to the corresponding shared library's base address.
